Some helpful info about using these scripts....

Scripts prefixed with "meta" or "meta-intel" are intended for use with
meta-intel BSP releases. These may ultimately move elsewhere, but for now there
are only a couple, so for convenience of the release engineer, they reside here.

Meta-intel scripts SHOULD NOT be used against Yocto releases, and vice versa.
Weird things happen due to differences in naming schemes, what artificats gets
published, and other factors. 

There is one exception to this naming scheme, and that is utils.py. This is
essentially a libary with some commonly reused functions. It is used by both the
Yocto- and meta-intel- specific scripts. Meta-intel functionality SHOULD NOT be
moved into utils.py for any reason.


There are a few categories of scripts:

- release scripts
  * release.py (Yocto ONLY)
  * uninative.py (Yocto)
  * unihash.py (used along with uninative.py for a uninative release)
  * meta-intel.py (meta-intel ONLY)

- release notes generation scripts
  * relnotes.py (Yocto)
  * meta-notes.py (meta-intel ONLY)
  * meta-intelsec-info.txt (used with meta-notes.py to inject the security fixes
    blurb into the release notes)

- utils/reused code
  * utils.py (Yocto AND meta-intel)

- useful things
  * get_cves.py (Yocto) Takes a revision range and spits out the CVES in the git
    log between the revisions. Works for poky. Not intended to necessarily work
    elsewhere. This is handy if you have a release that does not include some CVE
    fixes, but you want to list them in the Known Issues in RELEASENOTES for that
    release. The 2.6 Thud release is an example. This script was used to generate
    the list included in the Known Issues for the Thud release. 
  * get_hashes.py (Yocto. DOES NOT WORK with meta-intel) This looks in the RC
    directory and snags the hashes for the various tarballs we release. This
    info is passed to Michael Halstead who uses it for tagging repos. Also just
    generally useful. 
  * rel_type.py (Yocto) This lives in utils.py (definitive version), but is kind of handy by itself
    from time to time. 
  * where_am_i.py This snippet looks at the hostname and make a guess as to what
    path the autobuilder output will be found. The legacy path was
    /srv/www/vhosts. On newer AB clusters, this is now generally /srv/autobuilder.
   There is at least one case where this still applies. This wagers a guess as to
   which one to use based on which cluster we are on. Also lives in utils.py
   (definitive version), but is occasionally useful standalone.

Since usage help is available in each script, it is not included here.

Please note that since meta-intel is an Intel BSP release, and the scripts are
only included in this repo for convenience, for the time being, details on using
them, and the meta-intel release process, are not covered here. 


Yocto Release Process
=====================

This section deals with the Yocto release process as it pertains to the tools in
this repo. There are other release activities that happen which outside the
scope of this document. For more information on Yocto releases, please see:
https://wiki.yoctoproject.org/wiki/Yocto_Release_Engineering

Preparing the Release
---------------------

The scripts in this repo do two primary things: prepare the release directory
containing all the release artifacts, and generate the errata and release notes
as needed releases for each type of release (Major, Point or "Dot", and
Milestone). 

Preparing, or "staging," the release entails the following:

 1) Rsync the rc candidate to a staging dir where all work happens. We NEVER
touch the actual RC directory, for safety, in case something goes wrong.
  
2) Convert the symlinks in build-appliance dir. The build creates symlinks in
some places, and we don't want to release those. This is one such occurance, so
we convert that link to a real file.

3) Convert the symlinks in the machines subdirectory and clean up any files that
we don't wish to publish, such as .iso and .tgz files.

4) Rename the release tarballs with the release naming conventions. They start
out with just the commit hash in the filename. We "clean" that up and replace it
with the release codename (i.e. rocko, sumo, thud) and the Poky version (i.e.
18.0.0, 19.0.1, 20.0.0, etc). We then create a symlink with the original
filename with the hash to the new tarball. Not done for milestone releases.
   
5) We copy the Eclipse artifacts to a staging directory where they are made
available externally. To do this, we copy the Eclipse plugin archive file over
to the correct location, and explode it. This is not done for milestone
releases.

6) Make the BSP tarballs. For each machine in the machines subdirectory, we
repackage the :wq

        print "Generating the BSP tarballs."
        logging.info('Generating BSP tarballs.')
        make_bsps(BSP_LIST, BSP_DIR)
        logging.info('Successful.')

        # 7) Generate the master md5sum file for the release (for all releases, except milestones)
        print "Generating the master md5sum table."
        logging.info('Generating the master md5sum table.')
        gen_rel_md5(RELEASE_DIR, REL_MD5_FILE)
        logging.info('Successful.')


Contributing
============

This module is owned by Vineela Tummalapalli <vineela.tummalapalli@intel.com>.

Patches should be sent via git-send-email to the yocto@yoctoproject.org mailing list with
[release-tools] in the subject, CC'd to Vineela.

The following commands will configure this if ran inside a clone of release-tools:

$ git config  --local --add format.subjectprefix 'PATCH release-tools'
$ git config  --local --add sendemail.to yocto@yoctoproject.org
$ git config  --local --add sendemail.cc vineela.tummalapalli@intel.com

Then sending a patch is as simple as:

$ git send-email origin/master
